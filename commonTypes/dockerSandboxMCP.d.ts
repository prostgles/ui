export declare const indexTS = "\n\n\n\nimport { spawn, ChildProcess } from 'child_process';\nimport { EventEmitter } from 'events';\nimport { promises as fs } from 'fs';\nimport { join } from 'path';\nimport { randomUUID } from 'crypto';\n\nexport interface DockerConfig {\n  image: string;\n  workingDir?: string;\n  memory?: string;\n  cpus?: string;\n  timeout?: number;\n  networkMode?: 'none' | 'bridge' | 'host';\n  readOnly?: boolean;\n  user?: string;\n  environment?: Record<string, string>;\n  volumes?: Array<{ host: string; container: string; readOnly?: boolean }>;\n}\n\nexport interface ExecutionResult {\n  stdout: string;\n  stderr: string;\n  exitCode: number;\n  timedOut: boolean;\n  executionTime: number;\n}\n\nexport interface ContainerInfo {\n  id: string;\n  status: 'created' | 'running' | 'stopped' | 'error';\n  image: string;\n  createdAt: Date;\n}\n\nexport class DockerSandbox extends EventEmitter {\n  private containerId: string | null = null;\n  private containerName: string;\n  private config: DockerConfig;\n  private isRunning: boolean = false;\n  private tempDir: string;\n\n  constructor(config: DockerConfig) {\n    super();\n    this.config = {\n      workingDir: '/workspace',\n      memory: '512m',\n      cpus: '1',\n      timeout: 30000,\n      networkMode: 'none',\n      readOnly: false,\n      user: 'nobody',\n      ...config\n    };\n    this.containerName = `sandbox-${randomUUID()}`;\n    this.tempDir = join('/tmp', this.containerName);\n  }\n\n  /**\n   * Create and start the Docker container\n   */\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      throw new Error('Container is already running');\n    }\n\n    try {\n      // Create temporary directory for file sharing\n      await fs.mkdir(this.tempDir, { recursive: true });\n\n      // Build docker run command\n      const dockerArgs = this.buildDockerArgs();\n      \n      // Start container\n      const result = await this.executeCommand('docker', ['run', '-d', ...dockerArgs]);\n      \n      if (result.exitCode !== 0) {\n        throw new Error(`Failed to start container: ${result.stderr}`);\n      }\n\n      this.containerId = result.stdout.trim();\n      this.isRunning = true;\n      \n      this.emit('started', { containerId: this.containerId });\n      \n      // Wait for container to be ready\n      await this.waitForContainer();\n      \n    } catch (error) {\n      await this.cleanup();\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a command inside the container\n   */\n  async executeCommand(command: string, args: string[] = [], options: {\n    timeout?: number;\n    workingDir?: string;\n    user?: string;\n    environment?: Record<string, string>;\n  } = {}): Promise<ExecutionResult> {\n    const startTime = Date.now();\n    const timeout = options.timeout || this.config.timeout!;\n\n    return new Promise((resolve) => {\n      const child = spawn(command, args, {\n        stdio: ['pipe', 'pipe', 'pipe'],\n        env: { ...process.env, ...options.environment }\n      });\n\n      let stdout = '';\n      let stderr = '';\n      let timedOut = false;\n\n      // Set up timeout\n      const timeoutId = setTimeout(() => {\n        timedOut = true;\n        child.kill('SIGKILL');\n      }, timeout);\n\n      // Collect output\n      child.stdout?.on('data', (data) => {\n        stdout += data.toString();\n      });\n\n      child.stderr?.on('data', (data) => {\n        stderr += data.toString();\n      });\n\n      child.on('close', (code) => {\n        clearTimeout(timeoutId);\n        const executionTime = Date.now() - startTime;\n        \n        resolve({\n          stdout,\n          stderr,\n          exitCode: code || 0,\n          timedOut,\n          executionTime\n        });\n      });\n\n      child.on('error', (error) => {\n        clearTimeout(timeoutId);\n        resolve({\n          stdout,\n          stderr: stderr + error.message,\n          exitCode: -1,\n          timedOut,\n          executionTime: Date.now() - startTime\n        });\n      });\n    });\n  }\n\n  /**\n   * Execute code inside the container\n   */\n  async runCode(code: string, language: string = 'python', options: {\n    timeout?: number;\n    stdin?: string;\n  } = {}): Promise<ExecutionResult> {\n    if (!this.isRunning || !this.containerId) {\n      throw new Error('Container is not running');\n    }\n\n    const fileExtension = this.getFileExtension(language);\n    const fileName = `code_${Date.now()}.${fileExtension}`;\n    const filePath = join(this.tempDir, fileName);\n\n    try {\n      // Write code to file\n      await fs.writeFile(filePath, code);\n\n      // Build execution command\n      const execCommand = this.buildExecutionCommand(language, fileName);\n      const dockerExecArgs = [\n        'exec',\n        '-i',\n        '--user', this.config.user || 'nobody',\n        '--workdir', this.config.workingDir || '/workspace',\n        this.containerId,\n        ...execCommand\n      ];\n\n      const result = await this.executeCommand('docker', dockerExecArgs, {\n        timeout: options.timeout || this.config.timeout\n      });\n\n      this.emit('codeExecuted', {\n        language,\n        code,\n        result,\n        fileName\n      });\n\n      return result;\n\n    } catch (error) {\n      throw new Error(`Failed to execute code: ${error}`);\n    } finally {\n      // Clean up temporary file\n      try {\n        await fs.unlink(filePath);\n      } catch (e) {\n        // Ignore cleanup errors\n      }\n    }\n  }\n\n  /**\n   * Copy file to container\n   */\n  async copyToContainer(localPath: string, containerPath: string): Promise<void> {\n    if (!this.containerId) {\n      throw new Error('Container is not running');\n    }\n\n    const result = await this.executeCommand('docker', [\n      'cp',\n      localPath,\n      `${this.containerId}:${containerPath}`\n    ]);\n\n    if (result.exitCode !== 0) {\n      throw new Error(`Failed to copy file to container: ${result.stderr}`);\n    }\n  }\n\n  /**\n   * Copy file from container\n   */\n  async copyFromContainer(containerPath: string, localPath: string): Promise<void> {\n    if (!this.containerId) {\n      throw new Error('Container is not running');\n    }\n\n    const result = await this.executeCommand('docker', [\n      'cp',\n      `${this.containerId}:${containerPath}`,\n      localPath\n    ]);\n\n    if (result.exitCode !== 0) {\n      throw new Error(`Failed to copy file from container: ${result.stderr}`);\n    }\n  }\n\n  /**\n   * Get container information\n   */\n  async getContainerInfo(): Promise<ContainerInfo | null> {\n    if (!this.containerId) {\n      return null;\n    }\n\n    const result = await this.executeCommand('docker', [\n      'inspect',\n      '--format',\n      '{{.State.Status}}|{{.Config.Image}}|{{.Created}}',\n      this.containerId\n    ]);\n\n    if (result.exitCode !== 0) {\n      return null;\n    }\n\n    const [status, image, created] = result.stdout.trim().split('|');\n    \n    return {\n      id: this.containerId,\n      status: status as ContainerInfo['status'],\n      image,\n      createdAt: new Date(created)\n    };\n  }\n\n  /**\n   * Stop and remove the container\n   */\n  async stop(): Promise<void> {\n    if (!this.containerId) {\n      return;\n    }\n\n    try {\n      // Stop container\n      await this.executeCommand('docker', ['stop', this.containerId]);\n      \n      // Remove container\n      await this.executeCommand('docker', ['rm', this.containerId]);\n      \n      this.emit('stopped', { containerId: this.containerId });\n      \n    } catch (error) {\n      this.emit('error', error);\n    } finally {\n      await this.cleanup();\n    }\n  }\n\n  /**\n   * Get container logs\n   */\n  async getLogs(options: {\n    tail?: number;\n    since?: string;\n    follow?: boolean;\n  } = {}): Promise<string> {\n    if (!this.containerId) {\n      throw new Error('Container is not running');\n    }\n\n    const args = ['logs'];\n    \n    if (options.tail) {\n      args.push('--tail', options.tail.toString());\n    }\n    \n    if (options.since) {\n      args.push('--since', options.since);\n    }\n    \n    args.push(this.containerId);\n\n    const result = await this.executeCommand('docker', args);\n    return result.stdout;\n  }\n\n  /**\n   * Check if Docker is available\n   */\n  static async isDockerAvailable(): Promise<boolean> {\n    try {\n      const sandbox = new DockerSandbox({ image: 'hello-world' });\n      const result = await sandbox.executeCommand('docker', ['--version']);\n      return result.exitCode === 0;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Build Docker run arguments\n   */\n  private buildDockerArgs(): string[] {\n    const args = [\n      '--name', this.containerName,\n      '--rm',\n      '--interactive',\n      '--tty',\n      '--detach'\n    ];\n\n    // Resource limits\n    if (this.config.memory) {\n      args.push('--memory', this.config.memory);\n    }\n    \n    if (this.config.cpus) {\n      args.push('--cpus', this.config.cpus);\n    }\n\n    // Network settings\n    if (this.config.networkMode) {\n      args.push('--network', this.config.networkMode);\n    }\n\n    // User\n    if (this.config.user) {\n      args.push('--user', this.config.user);\n    }\n\n    // Read-only filesystem\n    if (this.config.readOnly) {\n      args.push('--read-only');\n    }\n\n    // Working directory\n    if (this.config.workingDir) {\n      args.push('--workdir', this.config.workingDir);\n    }\n\n    // Environment variables\n    if (this.config.environment) {\n      Object.entries(this.config.environment).forEach(([key, value]) => {\n        args.push('--env', `${key}=${value}`);\n      });\n    }\n\n    // Volumes\n    args.push('-v', `${this.tempDir}:${this.config.workingDir || '/workspace'}`);\n    \n    if (this.config.volumes) {\n      this.config.volumes.forEach(volume => {\n        const volumeStr = volume.readOnly \n          ? `${volume.host}:${volume.container}:ro`\n          : `${volume.host}:${volume.container}`;\n        args.push('-v', volumeStr);\n      });\n    }\n\n    // Security options\n    args.push('--security-opt', 'no-new-privileges');\n    args.push('--cap-drop', 'ALL');\n\n    // Image\n    args.push(this.config.image);\n\n    // Keep container running\n    args.push('tail', '-f', '/dev/null');\n\n    return args;\n  }\n\n  /**\n   * Build execution command for different languages\n   */\n  private buildExecutionCommand(language: string, fileName: string): string[] {\n    const filePath = join(this.config.workingDir || '/workspace', fileName);\n    \n    switch (language.toLowerCase()) {\n      case 'python':\n        return ['python3', filePath];\n      case 'javascript':\n      case 'node':\n        return ['node', filePath];\n      case 'bash':\n      case 'shell':\n        return ['bash', filePath];\n      case 'java':\n        const className = fileName.replace('.java', '');\n        return ['sh', '-c', `javac ${filePath} && java -cp ${this.config.workingDir} ${className}`];\n      case 'go':\n        return ['go', 'run', filePath];\n      default:\n        throw new Error(`Unsupported language: ${language}`);\n    }\n  }\n\n  /**\n   * Get file extension for language\n   */\n  private getFileExtension(language: string): string {\n    switch (language.toLowerCase()) {\n      case 'python': return 'py';\n      case 'javascript':\n      case 'node': return 'js';\n      case 'bash':\n      case 'shell': return 'sh';\n      case 'java': return 'java';\n      case 'go': return 'go';\n      default: return 'txt';\n    }\n  }\n\n  /**\n   * Wait for container to be ready\n   */\n  private async waitForContainer(): Promise<void> {\n    const maxAttempts = 30;\n    let attempts = 0;\n\n    while (attempts < maxAttempts) {\n      try {\n        const info = await this.getContainerInfo();\n        if (info && info.status === 'running') {\n          return;\n        }\n      } catch (error) {\n        // Continue waiting\n      }\n\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      attempts++;\n    }\n\n    throw new Error('Container failed to start within timeout');\n  }\n\n  /**\n   * Clean up resources\n   */\n  private async cleanup(): Promise<void> {\n    this.isRunning = false;\n    this.containerId = null;\n\n    try {\n      await fs.rmdir(this.tempDir, { recursive: true });\n    } catch (error) {\n      // Ignore cleanup errors\n    }\n  }\n}\n\n\n// server.ts\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ErrorCode,\n  ListToolsRequestSchema,\n  McpError,\n  Tool,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\ninterface ActiveSandbox {\n  id: string;\n  sandbox: DockerSandbox;\n  config: DockerConfig;\n  createdAt: Date;\n  lastUsed: Date;\n}\n\nclass DockerSandboxMCPServer {\n  private server: Server;\n  private activeSandboxes: Map<string, ActiveSandbox> = new Map();\n  private readonly MAX_SANDBOXES = 10;\n  private readonly SANDBOX_TIMEOUT = 30 * 60 * 1000; // 30 minutes\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"docker-sandbox-server\",\n        version: \"1.0.0\",\n        description: \"MCP server for executing code in Docker containers\",\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    );\n\n    this.setupToolHandlers();\n    this.setupCleanupInterval();\n  }\n\n  private setupToolHandlers(): void {\n    this.server.setRequestHandler(ListToolsRequestSchema, async () => {\n      return {\n        tools: [\n          {\n            name: \"create_sandbox\",\n            description: \"Create a new Docker sandbox container\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                image: {\n                  type: \"string\",\n                  description: \"Docker image to use (e.g., 'python:3.9-slim', 'node:18-alpine')\",\n                },\n                language: {\n                  type: \"string\",\n                  enum: [\"python\", \"javascript\", \"node\", \"bash\", \"java\", \"go\"],\n                  description: \"Primary language for the sandbox\",\n                },\n                memory: {\n                  type: \"string\",\n                  description: \"Memory limit (e.g., '512m', '1g')\",\n                  default: \"512m\",\n                },\n                cpus: {\n                  type: \"string\",\n                  description: \"CPU limit (e.g., '0.5', '1')\",\n                  default: \"1\",\n                },\n                timeout: {\n                  type: \"number\",\n                  description: \"Default timeout for operations in milliseconds\",\n                  default: 30000,\n                },\n                networkMode: {\n                  type: \"string\",\n                  enum: [\"none\", \"bridge\", \"host\"],\n                  description: \"Network mode for the container\",\n                  default: \"none\",\n                },\n                environment: {\n                  type: \"object\",\n                  description: \"Environment variables to set in the container\",\n                  additionalProperties: { type: \"string\" },\n                },\n              },\n              required: [\"image\"],\n            },\n          },\n          {\n            name: \"execute_code\",\n            description: \"Execute code in a sandbox container\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                sandboxId: {\n                  type: \"string\",\n                  description: \"ID of the sandbox container\",\n                },\n                code: {\n                  type: \"string\",\n                  description: \"Code to execute\",\n                },\n                language: {\n                  type: \"string\",\n                  enum: [\"python\", \"javascript\", \"node\", \"bash\", \"java\", \"go\"],\n                  description: \"Programming language\",\n                },\n                timeout: {\n                  type: \"number\",\n                  description: \"Timeout for execution in milliseconds\",\n                },\n                stdin: {\n                  type: \"string\",\n                  description: \"Standard input to provide to the code\",\n                },\n              },\n              required: [\"sandboxId\", \"code\", \"language\"],\n            },\n          },\n          {\n            name: \"list_sandboxes\",\n            description: \"List all active sandbox containers\",\n            inputSchema: {\n              type: \"object\",\n              properties: {},\n            },\n          },\n          {\n            name: \"get_sandbox_info\",\n            description: \"Get information about a specific sandbox\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                sandboxId: {\n                  type: \"string\",\n                  description: \"ID of the sandbox container\",\n                },\n              },\n              required: [\"sandboxId\"],\n            },\n          },\n          {\n            name: \"copy_file_to_sandbox\",\n            description: \"Copy a file to a sandbox container\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                sandboxId: {\n                  type: \"string\",\n                  description: \"ID of the sandbox container\",\n                },\n                content: {\n                  type: \"string\",\n                  description: \"File content to copy\",\n                },\n                containerPath: {\n                  type: \"string\",\n                  description: \"Path in the container where to save the file\",\n                },\n              },\n              required: [\"sandboxId\", \"content\", \"containerPath\"],\n            },\n          },\n          {\n            name: \"get_sandbox_logs\",\n            description: \"Get logs from a sandbox container\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                sandboxId: {\n                  type: \"string\",\n                  description: \"ID of the sandbox container\",\n                },\n                tail: {\n                  type: \"number\",\n                  description: \"Number of lines to tail\",\n                  default: 100,\n                },\n                since: {\n                  type: \"string\",\n                  description: \"Show logs since timestamp\",\n                },\n              },\n              required: [\"sandboxId\"],\n            },\n          },\n          {\n            name: \"stop_sandbox\",\n            description: \"Stop and remove a sandbox container\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                sandboxId: {\n                  type: \"string\",\n                  description: \"ID of the sandbox container\",\n                },\n              },\n              required: [\"sandboxId\"],\n            },\n          },\n          {\n            name: \"check_docker_availability\",\n            description: \"Check if Docker is available on the system\",\n            inputSchema: {\n              type: \"object\",\n              properties: {},\n            },\n          },\n          {\n            name: \"run_quick_code\",\n            description: \"Create a temporary sandbox, run code, and clean up automatically\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                code: {\n                  type: \"string\",\n                  description: \"Code to execute\",\n                },\n                language: {\n                  type: \"string\",\n                  enum: [\"python\", \"javascript\", \"node\", \"bash\", \"java\", \"go\"],\n                  description: \"Programming language\",\n                },\n                image: {\n                  type: \"string\",\n                  description: \"Docker image to use (optional, will use default for language)\",\n                },\n                timeout: {\n                  type: \"number\",\n                  description: \"Timeout for execution in milliseconds\",\n                  default: 30000,\n                },\n                memory: {\n                  type: \"string\",\n                  description: \"Memory limit\",\n                  default: \"512m\",\n                },\n                environment: {\n                  type: \"object\",\n                  description: \"Environment variables\",\n                  additionalProperties: { type: \"string\" },\n                },\n              },\n              required: [\"code\", \"language\"],\n            },\n          },\n        ],\n      };\n    });\n\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {\n      const { name, arguments: args } = request.params;\n\n      try {\n        switch (name) {\n          case \"create_sandbox\":\n            return await this.createSandbox(args);\n          case \"execute_code\":\n            return await this.executeCode(args);\n          case \"list_sandboxes\":\n            return await this.listSandboxes();\n          case \"get_sandbox_info\":\n            return await this.getSandboxInfo(args);\n          case \"copy_file_to_sandbox\":\n            return await this.copyFileToSandbox(args);\n          case \"get_sandbox_logs\":\n            return await this.getSandboxLogs(args);\n          case \"stop_sandbox\":\n            return await this.stopSandbox(args);\n          case \"check_docker_availability\":\n            return await this.checkDockerAvailability();\n          case \"run_quick_code\":\n            return await this.runQuickCode(args);\n          default:\n            throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${name}`);\n        }\n      } catch (error) {\n        if (error instanceof McpError) {\n          throw error;\n        }\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Error executing tool ${name}: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    });\n  }\n\n  private async createSandbox(args: any) {\n    if (this.activeSandboxes.size >= this.MAX_SANDBOXES) {\n      throw new McpError(\n        ErrorCode.InvalidRequest,\n        `Maximum number of sandboxes (${this.MAX_SANDBOXES}) reached`\n      );\n    }\n\n    const config: DockerConfig = {\n      image: args.image,\n      memory: args.memory || \"512m\",\n      cpus: args.cpus || \"1\",\n      timeout: args.timeout || 30000,\n      networkMode: args.networkMode || \"none\",\n      environment: args.environment || {},\n    };\n\n    const sandbox = new DockerSandbox(config);\n    const sandboxId = `sandbox-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n    try {\n      await sandbox.start();\n\n      const activeSandbox: ActiveSandbox = {\n        id: sandboxId,\n        sandbox,\n        config,\n        createdAt: new Date(),\n        lastUsed: new Date(),\n      };\n\n      this.activeSandboxes.set(sandboxId, activeSandbox);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify({\n              success: true,\n              sandboxId,\n              message: \"Sandbox created successfully\",\n              config: {\n                image: config.image,\n                memory: config.memory,\n                cpus: config.cpus,\n                networkMode: config.networkMode,\n              },\n            }, null, 2),\n          },\n        ],\n      };\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Failed to create sandbox: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  private async executeCode(args: any) {\n    const { sandboxId, code, language, timeout, stdin } = args;\n    const activeSandbox = this.activeSandboxes.get(sandboxId);\n\n    if (!activeSandbox) {\n      throw new McpError(ErrorCode.InvalidRequest, `Sandbox ${sandboxId} not found`);\n    }\n\n    activeSandbox.lastUsed = new Date();\n\n    try {\n      const result = await activeSandbox.sandbox.runCode(code, language, {\n        timeout,\n        stdin,\n      });\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify({\n              success: true,\n              result: {\n                stdout: result.stdout,\n                stderr: result.stderr,\n                exitCode: result.exitCode,\n                timedOut: result.timedOut,\n                executionTime: result.executionTime,\n              },\n              sandboxId,\n              language,\n            }, null, 2),\n          },\n        ],\n      };\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Failed to execute code: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  private async listSandboxes() {\n    const sandboxes = Array.from(this.activeSandboxes.values()).map(sandbox => ({\n      id: sandbox.id,\n      image: sandbox.config.image,\n      createdAt: sandbox.createdAt,\n      lastUsed: sandbox.lastUsed,\n      memory: sandbox.config.memory,\n      cpus: sandbox.config.cpus,\n    }));\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify({\n            success: true,\n            sandboxes,\n            total: sandboxes.length,\n          }, null, 2),\n        },\n      ],\n    };\n  }\n\n  private async getSandboxInfo(args: any) {\n    const { sandboxId } = args;\n    const activeSandbox = this.activeSandboxes.get(sandboxId);\n\n    if (!activeSandbox) {\n      throw new McpError(ErrorCode.InvalidRequest, `Sandbox ${sandboxId} not found`);\n    }\n\n    try {\n      const containerInfo = await activeSandbox.sandbox.getContainerInfo();\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify({\n              success: true,\n              sandbox: {\n                id: activeSandbox.id,\n                config: activeSandbox.config,\n                createdAt: activeSandbox.createdAt,\n                lastUsed: activeSandbox.lastUsed,\n                containerInfo,\n              },\n            }, null, 2),\n          },\n        ],\n      };\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Failed to get sandbox info: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  private async copyFileToSandbox(args: any) {\n    const { sandboxId, content, containerPath } = args;\n    const activeSandbox = this.activeSandboxes.get(sandboxId);\n\n    if (!activeSandbox) {\n      throw new McpError(ErrorCode.InvalidRequest, `Sandbox ${sandboxId} not found`);\n    }\n\n    activeSandbox.lastUsed = new Date();\n\n    try {\n      // Create temporary file\n      const tempFile = `/tmp/mcp-${Date.now()}.tmp`;\n      const fs = await import('fs/promises');\n      await fs.writeFile(tempFile, content);\n      \n      await activeSandbox.sandbox.copyToContainer(tempFile, containerPath);\n      \n      // Clean up temp file\n      await fs.unlink(tempFile);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify({\n              success: true,\n              message: `File copied to ${containerPath}`,\n              sandboxId,\n            }, null, 2),\n          },\n        ],\n      };\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Failed to copy file: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  private async getSandboxLogs(args: any) {\n    const { sandboxId, tail, since } = args;\n    const activeSandbox = this.activeSandboxes.get(sandboxId);\n\n    if (!activeSandbox) {\n      throw new McpError(ErrorCode.InvalidRequest, `Sandbox ${sandboxId} not found`);\n    }\n\n    try {\n      const logs = await activeSandbox.sandbox.getLogs({ tail, since });\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify({\n              success: true,\n              logs,\n              sandboxId,\n            }, null, 2),\n          },\n        ],\n      };\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Failed to get logs: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  private async stopSandbox(args: any) {\n    const { sandboxId } = args;\n    const activeSandbox = this.activeSandboxes.get(sandboxId);\n\n    if (!activeSandbox) {\n      throw new McpError(ErrorCode.InvalidRequest, `Sandbox ${sandboxId} not found`);\n    }\n\n    try {\n      await activeSandbox.sandbox.stop();\n      this.activeSandboxes.delete(sandboxId);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify({\n              success: true,\n              message: `Sandbox ${sandboxId} stopped successfully`,\n            }, null, 2),\n          },\n        ],\n      };\n    } catch (error) {\n      // Remove from active sandboxes even if stop failed\n      this.activeSandboxes.delete(sandboxId);\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Failed to stop sandbox: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  private async checkDockerAvailability() {\n    try {\n      const isAvailable = await DockerSandbox.isDockerAvailable();\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify({\n              success: true,\n              dockerAvailable: isAvailable,\n              message: isAvailable ? \"Docker is available\" : \"Docker is not available\",\n            }, null, 2),\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify({\n              success: false,\n              dockerAvailable: false,\n              error: error instanceof Error ? error.message : String(error),\n            }, null, 2),\n          },\n        ],\n      };\n    }\n  }\n\n  private async runQuickCode(args: any) {\n    const { code, language, image, timeout, memory, environment } = args;\n    \n    // Default images for common languages\n    const defaultImages: Record<string, string> = {\n      python: \"python:3.9-slim\",\n      javascript: \"node:18-alpine\",\n      node: \"node:18-alpine\",\n      bash: \"ubuntu:20.04\",\n      java: \"openjdk:11-jre-slim\",\n      go: \"golang:1.19-alpine\",\n    };\n\n    const config: DockerConfig = {\n      image: image || defaultImages[language] || \"ubuntu:20.04\",\n      memory: memory || \"512m\",\n      cpus: \"1\",\n      timeout: timeout || 30000,\n      networkMode: \"none\",\n      environment: environment || {},\n    };\n\n    const sandbox = new DockerSandbox(config);\n\n    try {\n      await sandbox.start();\n      \n      const result = await sandbox.runCode(code, language, {\n        timeout: timeout || 30000,\n      });\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify({\n              success: true,\n              result: {\n                stdout: result.stdout,\n                stderr: result.stderr,\n                exitCode: result.exitCode,\n                timedOut: result.timedOut,\n                executionTime: result.executionTime,\n              },\n              language,\n              image: config.image,\n            }, null, 2),\n          },\n        ],\n      };\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Failed to execute quick code: ${error instanceof Error ? error.message : String(error)}`\n      );\n    } finally {\n      // Always clean up the temporary sandbox\n      try {\n        await sandbox.stop();\n      } catch (error) {\n        // Ignore cleanup errors\n      }\n    }\n  }\n\n  private setupCleanupInterval(): void {\n    setInterval(() => {\n      const now = new Date();\n      \n      for (const [sandboxId, activeSandbox] of this.activeSandboxes) {\n        const timeSinceLastUse = now.getTime() - activeSandbox.lastUsed.getTime();\n        \n        if (timeSinceLastUse > this.SANDBOX_TIMEOUT) {\n          console.log(`Cleaning up inactive sandbox: ${sandboxId}`);\n          activeSandbox.sandbox.stop().catch(console.error);\n          this.activeSandboxes.delete(sandboxId);\n        }\n      }\n    }, 5 * 60 * 1000); // Check every 5 minutes\n  }\n\n  async run(): Promise<void> {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"Docker Sandbox MCP server running on stdio\");\n  }\n\n  async shutdown(): Promise<void> {\n    // Stop all active sandboxes\n    const stopPromises = Array.from(this.activeSandboxes.values()).map(\n      activeSandbox => activeSandbox.sandbox.stop()\n    );\n    \n    await Promise.allSettled(stopPromises);\n    this.activeSandboxes.clear();\n  }\n}\n\n// Handle graceful shutdown\nprocess.on('SIGINT', async () => {\n  console.error('Received SIGINT, shutting down gracefully...');\n  await server.shutdown();\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', async () => {\n  console.error('Received SIGTERM, shutting down gracefully...');\n  await server.shutdown();\n  process.exit(0);\n});\n\nconst server = new DockerSandboxMCPServer();\nserver.run().catch(console.error);\n";
export declare const packageJSON = "// package.json\n{\n  \"name\": \"docker-sandbox-mcp-server\",\n  \"version\": \"1.0.0\",\n  \"description\": \"MCP server for executing code in Docker containers\",\n  \"type\": \"module\",\n  \"main\": \"dist/server.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"dev\": \"tsc --watch\",\n    \"start\": \"node dist/server.js\",\n    \"clean\": \"rm -rf dist\"\n  },\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^0.4.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"typescript\": \"^5.0.0\"\n  },\n  \"bin\": {\n    \"docker-sandbox-mcp\": \"./dist/server.js\"\n  },\n  \"files\": [\n    \"dist/\"\n  ]\n}";
export declare const tsconfigJSON = "\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ES2022\",\n    \"lib\": [\"ES2022\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"moduleResolution\": \"node\",\n    \"allowSyntheticDefaultImports\": true,\n    \"resolveJsonModule\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}";
